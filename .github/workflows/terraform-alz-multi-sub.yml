
name: Terraform ALZ Deploy (Multi-Subscription)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "GitHub Environment to use (e.g., eir-business-dev)"
        required: true
        default: "eir-business-dev"
        type: string
      target:
        description: "Terraform root to run (maps to backend-config/<target>.hcl)"
        required: true
        type: choice
        options:
          - tenant
          - connectivity
          - connectivity-bastion
          - connectivity-gateway
          - connectivity-peerings
          - identity
          - identity-routes
          - management
          - management-routes
          - security
          - security-routes
          - lz-nonprod
          - lz-nonprod-routes
          - lz-prod
          - lz-prod-routes
      action:
        description: "plan or apply"
        required: true
        default: plan
        type: choice
        options: [plan, apply]

permissions:
  contents: read
  id-token: write  # Required for GitHub OIDC -> Azure token exchange

jobs:
  terraform:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    env:
      TF_VERSION: "1.8.0"
      TF_IN_AUTOMATION: "true"
      TF_INPUT: "false"
      AZURE_CORE_OUTPUT: "none"

      # From GitHub Environment variables
      AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}

      SUB_CONNECTIVITY: ${{ vars.SUB_CONNECTIVITY }}
      SUB_IDENTITY:     ${{ vars.SUB_IDENTITY }}
      SUB_SECURITY:     ${{ vars.SUB_SECURITY }}
      SUB_MANAGEMENT:   ${{ vars.SUB_MANAGEMENT }}
      SUB_PROD:         ${{ vars.SUB_PROD }}
      SUB_NONPROD:      ${{ vars.SUB_NONPROD }}

      # Force Terraform AzureRM Provider to use OIDC (not Azure CLI user auth)
      ARM_USE_OIDC: "true"
      ARM_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          allow-no-subscriptions: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Resolve paths + subscription mapping
        id: map
        shell: bash
        run: |
          TARGET="${{ inputs.target }}"
          BACKEND_FILE="${GITHUB_WORKSPACE}/backend-config/${TARGET}.hcl"

          case "$TARGET" in
            tenant)
              WORKDIR="deployments/tenant"
              SUB="${SUB_MANAGEMENT}"
              ;;

            connectivity)
              WORKDIR="deployments/platform/connectivity"
              SUB="${SUB_CONNECTIVITY}"
              ;;
            connectivity-bastion)
              WORKDIR="deployments/platform/connectivity/bastion"
              SUB="${SUB_CONNECTIVITY}"
              ;;
            connectivity-gateway)
              WORKDIR="deployments/platform/connectivity/gateway"
              SUB="${SUB_CONNECTIVITY}"
              ;;
            connectivity-peerings)
              WORKDIR="deployments/platform/connectivity/peerings"
              SUB="${SUB_CONNECTIVITY}"
              ;;

            identity)
              WORKDIR="deployments/platform/identity"
              SUB="${SUB_IDENTITY}"
              ;;
            identity-routes)
              WORKDIR="deployments/platform/identity/routes"
              SUB="${SUB_IDENTITY}"
              ;;

            management)
              WORKDIR="deployments/platform/management"
              SUB="${SUB_MANAGEMENT}"
              ;;
            management-routes)
              WORKDIR="deployments/platform/management/routes"
              SUB="${SUB_MANAGEMENT}"
              ;;

            security)
              WORKDIR="deployments/platform/security"
              SUB="${SUB_SECURITY}"
              ;;
            security-routes)
              WORKDIR="deployments/platform/security/routes"
              SUB="${SUB_SECURITY}"
              ;;

            lz-prod)
              WORKDIR="deployments/landingzones/lz-prod"
              SUB="${SUB_PROD}"
              ;;
            lz-prod-routes)
              WORKDIR="deployments/landingzones/lz-prod/routes"
              SUB="${SUB_PROD}"
              ;;

            lz-nonprod)
              WORKDIR="deployments/landingzones/lz-nonprod"
              SUB="${SUB_NONPROD}"
              ;;
            lz-nonprod-routes)
              WORKDIR="deployments/landingzones/lz-nonprod/routes"
              SUB="${SUB_NONPROD}"
              ;;

            *)
              echo "Unknown target: $TARGET"
              exit 1
              ;;
          esac

          if [ -z "$SUB" ] || [ "$SUB" = "xxxxx" ] || [[ "$SUB" =~ ^x+$ ]]; then
            echo "Subscription mapping for '$TARGET' is empty/placeholder. Populate SUB_* variables in GitHub Environment."
            exit 1
          fi

          echo "workdir=$WORKDIR" >> $GITHUB_OUTPUT
          echo "backend_file=$BACKEND_FILE" >> $GITHUB_OUTPUT
          echo "subscription=$SUB" >> $GITHUB_OUTPUT

          echo "Target: $TARGET"
          echo "Workdir: $WORKDIR"
          echo "Backend: $BACKEND_FILE"
          echo "Subscription: $SUB"

      # NEW: pick the subscription used to access the state store
      - name: Select ARM subscription for state access
        id: stateSub
        shell: bash
        run: |
          TARGET="${{ inputs.target }}"
          case "$TARGET" in
            connectivity-bastion|connectivity-gateway|connectivity-peerings|identity-routes|management-routes|security-routes|lz-nonprod-routes|lz-prod-routes)
              # These read remote state from storage in Management
              echo "arm_sub=${{ env.SUB_MANAGEMENT }}" >> $GITHUB_OUTPUT
              ;;
            *)
              # Others can use their mapped subscription for backend too
              echo "arm_sub=${{ steps.map.outputs.subscription }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Detect terraform.tfvars
        id: tfvars
        working-directory: ${{ steps.map.outputs.workdir }}
        shell: bash
        run: |
          if [ -f "terraform.tfvars" ]; then
            echo "has_tfvars=true" >> $GITHUB_OUTPUT
            echo "Found terraform.tfvars in $(pwd)"
          else
            echo "has_tfvars=false" >> $GITHUB_OUTPUT
            echo "No terraform.tfvars in $(pwd); proceeding without -var-file"
          fi

      - name: Terraform Init (remote state)
        working-directory: ${{ steps.map.outputs.workdir }}
        shell: bash
        env:
          ARM_SUBSCRIPTION_ID: ${{ steps.stateSub.outputs.arm_sub }}
        run: |
          terraform init -backend-config="${{ steps.map.outputs.backend_file }}"

      - name: Terraform Validate
        working-directory: ${{ steps.map.outputs.workdir }}
        run: terraform validate

      - name: Terraform Plan
        if: ${{ inputs.action == 'plan' }}
        working-directory: ${{ steps.map.outputs.workdir }}
        shell: bash
        env:
          ARM_SUBSCRIPTION_ID: ${{ steps.stateSub.outputs.arm_sub }}
        run: |
          if [ "${{ inputs.target }}" = "connectivity-peerings" ]; then
            # Peerings needs all six subscription IDs
            TFVARS_OPT=""
            if [ "${{ steps.tfvars.outputs.has_tfvars }}" = "true" ]; then TFVARS_OPT='-var-file="terraform.tfvars"'; fi
            terraform plan $TFVARS_OPT \
              -var "sub_connectivity=${{ env.SUB_CONNECTIVITY }}" \
              -var "sub_identity=${{ env.SUB_IDENTITY }}" \
              -var "sub_management=${{ env.SUB_MANAGEMENT }}" \
              -var "sub_security=${{ env.SUB_SECURITY }}" \
              -var "sub_lz_prod=${{ env.SUB_PROD }}" \
              -var "sub_lz_nonprod=${{ env.SUB_NONPROD }}"
          else
            if [ "${{ steps.tfvars.outputs.has_tfvars }}" = "true" ]; then
              if [ "${{ inputs.target }}" = "tenant" ]; then
                terraform plan -var-file="terraform.tfvars"
              else
                terraform plan -var-file="terraform.tfvars" -var "subscription_id=${{ steps.map.outputs.subscription }}"
              fi
            else
              if [ "${{ inputs.target }}" = "tenant" ]; then
                terraform plan
              else
                terraform plan -var "subscription_id=${{ steps.map.outputs.subscription }}"
              fi
            fi
          fi

      - name: Terraform Apply
        if: ${{ inputs.action == 'apply' }}
        working-directory: ${{ steps.map.outputs.workdir }}
        shell: bash
        env:
          ARM_SUBSCRIPTION_ID: ${{ steps.stateSub.outputs.arm_sub }}
        run: |
          if [ "${{ inputs.target }}" = "connectivity-peerings" ]; then
            TFVARS_OPT=""
            if [ "${{ steps.tfvars.outputs.has_tfvars }}" = "true" ]; then TFVARS_OPT='-var-file="terraform.tfvars"'; fi
            terraform apply -auto-approve $TFVARS_OPT \
              -var "sub_connectivity=${{ env.SUB_CONNECTIVITY }}" \
              -var "sub_identity=${{ env.SUB_IDENTITY }}" \
              -var "sub_management=${{ env.SUB_MANAGEMENT }}" \
              -var "sub_security=${{ env.SUB_SECURITY }}" \
              -var "sub_lz_prod=${{ env.SUB_PROD }}" \
              -var "sub_lz_nonprod=${{ env.SUB_NONPROD }}"
          else
            if [ "${{ steps.tfvars.outputs.has_tfvars }}" = "true" ]; then
              if [ "${{ inputs.target }}" = "tenant" ]; then
                terraform apply -auto-approve -var-file="terraform.tfvars"
              else
                terraform apply -auto-approve -var-file="terraform.tfvars" -var "subscription_id=${{ steps.map.outputs.subscription }}"
              fi
            else
              if [ "${{ inputs.target }}" = "tenant" ]; then
                terraform apply -auto-approve
              else
                terraform apply -auto-approve -var "subscription_id=${{ steps.map.outputs.subscription }}"
              fi
            fi
          fi
